generator client {
  provider      = "prisma-client-js"
  output        = "../src/generated/prisma"
  binaryTargets = ["native", "debian-openssl-3.0.x", "rhel-openssl-3.0.x"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model Expert {
  id                 String     @id @default(uuid())
  slug               String     @unique
  name               String
  profile_image      String?
  company            String?
  average_rating     Float      @default(0)
  total_reviews      Int        @default(0)
  hourly_rate_usd    Int?
  hourly_rate_nis    Int?
  languages          String
  verified           Boolean    @default(false)
  active             Boolean    @default(true)
  status             String     @default("pending") // pending, approved, rejected
  linkedin_profile   String?
  cv_url             String?
  created_at         DateTime   @default(now())
  updated_at         DateTime   @updatedAt
  email              String?    @unique
  bio_en             String?
  bio_he             String?
  name_he            String?
  specializations_en String?
  specializations_he String?
  title_en           String?
  title_he           String?
  bookings           Booking[]
  offerings          Offering[]
  reviews            Review[]
  specializations_list Specialization[] @relation("ExpertSpecializations")
  bids               Bid[]
  userId             String?    @unique
  user               User?      @relation(fields: [userId], references: [id])
}

model Offering {
  id                String    @id @default(uuid())
  expert_id         String
  title             String
  type              String    @default("lecture") // lecture, workshop, advisory
  description       String
  format            String
  duration_minutes  Int
  max_attendees     Int?
  price_usd         Int
  price_nis         Int?
  audience_level    String
  includes          String?
  target_industries String?
  customizable      Boolean   @default(false)
  active            Boolean   @default(true)
  created_at        DateTime  @default(now())
  updated_at        DateTime  @updatedAt
  bookings          Booking[]
  expert            Expert    @relation(fields: [expert_id], references: [id], onDelete: Cascade)
}

model Booking {
  id                   String    @id @default(uuid())
  expert_id            String
  offering_id          String
  company_name         String
  company_contact_name String
  company_email        String
  company_phone        String?
  date_requested       DateTime
  attendees_count      Int?
  notes_from_client    String?
  status               String    @default("pending")
  quote_amount_usd     Int
  quote_amount_nis     Int?
  payment_method       String    @default("pending")
  payment_status       String    @default("unpaid")
  stripe_payment_id    String?
  platform_fee_usd     Int?
  platform_fee_nis     Int?
  expert_payout_usd    Int?
  expert_payout_nis    Int?
  notes_from_expert    String?
  payment_link         String?   // URL to Morning/Grow payment page
  invoice_link         String?   // URL to the generated invoice
  transaction_id       String?   // External transaction ID
  expert_response_date DateTime?
  event_date_confirmed DateTime?
  review_sent          Boolean   @default(false)
  created_at           DateTime  @default(now())
  updated_at           DateTime  @updatedAt
  expert               Expert    @relation(fields: [expert_id], references: [id])
  offering             Offering  @relation(fields: [offering_id], references: [id])
  reviews              Review[]
}

model Review {
  id           String   @id @default(uuid())
  booking_id   String?
  expert_id    String
  company_name String
  rating       Int
  title        String?
  text         String
  verified     Boolean  @default(false)
  created_at   DateTime @default(now())
  booking      Booking? @relation(fields: [booking_id], references: [id])
  expert       Expert   @relation(fields: [expert_id], references: [id])
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  role          String    @default("USER") // USER, EXPERT, ADMIN
  expert        Expert?
  accounts      Account[]
  sessions      Session[]
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Category {
  id      String     @id @default(uuid())
  slug    String     @unique
  name_he String
  name_en String
  posts   BlogPost[]
}

model BlogPost {
  id          String   @id @default(uuid())
  slug        String   @unique
  title_he    String
  title_en    String
  excerpt_he  String
  excerpt_en  String
  content_he  String
  content_en  String
  cover_image String?
  published   Boolean  @default(false)
  publishedAt DateTime @default(now())
  category_id String
  author_name String
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt
  category    Category @relation(fields: [category_id], references: [id])
  faqs        FAQ[]
}

model FAQ {
  id          String   @id @default(uuid())
  question_he String
  answer_he   String
  question_en String
  answer_en   String
  post_id     String
  post        BlogPost @relation(fields: [post_id], references: [id], onDelete: Cascade)
}

model Specialization {
  id             String   @id @default(uuid())
  slug           String   @unique
  name_he        String
  name_en        String
  description_he String?  @db.Text
  description_en String?  @db.Text
  experts        Expert[] @relation("ExpertSpecializations")
  tasks          Task[]   @relation("TaskSpecializations")
  metaTitle_he   String?
  metaTitle_en   String?
  metaDescription_he String?  @db.Text
  metaDescription_en String?  @db.Text
  created_at     DateTime @default(now())
  updated_at     DateTime @updatedAt
}

model Task {
  id              String   @id @default(uuid())
  slug            String   @unique
  title           String
  description     String   @db.Text
  budget_range    String?  // e.g. "500-1000", "Fixed", "Hourly"
  status          String   @default("open") // open, closed, in_progress, completed
  approved        Boolean  @default(false) // Manual approval required before public display
  client_name     String?
  client_email    String?
  client_company  String?
  
  // Relations
  specializations Specialization[] @relation("TaskSpecializations")
  bids            Bid[]
  
  created_at      DateTime @default(now())
  updated_at      DateTime @updatedAt
}

model Bid {
  id          String   @id @default(uuid())
  task_id     String
  expert_id   String
  amount      Int?
  message     String?  @db.Text
  status      String   @default("pending") // pending, short-listed, rejected, won
  
  // Relations
  task        Task     @relation(fields: [task_id], references: [id], onDelete: Cascade)
  expert      Expert   @relation(fields: [expert_id], references: [id], onDelete: Cascade)
  
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  @@unique([task_id, expert_id])
}
